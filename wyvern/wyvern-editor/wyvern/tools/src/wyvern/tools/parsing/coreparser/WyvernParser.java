/* WyvernParser.java */
/* Generated By:JavaCC: Do not edit this line. WyvernParser.java */
package wyvern.tools.parsing.coreparser;

import wyvern.tools.typedAST.abs.*;
import wyvern.tools.typedAST.interfaces.*;
import wyvern.tools.typedAST.core.*;
import wyvern.tools.typedAST.core.values.*;
import wyvern.tools.typedAST.core.binding.*;
import wyvern.tools.typedAST.core.expressions.*;
import wyvern.tools.typedAST.core.declarations.*;
import wyvern.tools.errors.*;
import wyvern.tools.lexing.LexerUtils;
import wyvern.tools.generics.*;

import java.math.BigInteger;
import java.net.URI;
import java.util.*;

public class WyvernParser<AST,Type> implements WyvernParserConstants {
    private int number = 0;

    public FileLocation loc(Token t) {
        return new FileLocation(getTM().getFilename(), t.beginLine, t.beginColumn);
    }

    public WyvernTokenManager getTM() {
        return (WyvernTokenManager) token_source;
    }

    public String freshName() {
        return "ignoreme" + number++;
    }

    private ASTBuilder<AST,Type> build;
    public void setBuilder(ASTBuilder<AST,Type> builder) { build = builder; }

    private enum IndentedExpKind {
        NEW_KIND, DSL_KIND, INVOKE_KIND,
    }

    private class ExpFlags {
        public boolean isEmpty() { return exp == null; }
        public void setExp(AST a, IndentedExpKind kind) throws ParseException {
                final IndentedExpKind INVOKE_KIND = IndentedExpKind.INVOKE_KIND;

            // error to have two news in one expression
            if (!isEmpty() && this.kind != INVOKE_KIND && kind != INVOKE_KIND)
                throw new ParseException("May not have two \u005c"new\u005c" or \u005c"DSL literal\u005c" expressions within the same line");
            if (kind == INVOKE_KIND && this.kind != null && this.kind != INVOKE_KIND)
                return; // don't override a new or DSL literal with an invocation
            // otherwise update 
            exp = a;
            this.kind = kind;
        }
        public AST getExp() { return exp; }
        public IndentedExpKind getExpKind() { return kind; }

        private AST exp;
        private IndentedExpKind kind;
    }

/** Root production. */
  final public AST CompilationUnit() throws ParseException {LinkedList<AST> imports= new LinkedList<AST>(); AST exp; LinkedList<AST> requires = new LinkedList<AST>();
    ImportDecls(imports);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MODULE:{
      exp = ModuleDecl(imports);
{if ("" != null) return exp;}
      break;
      }
    case VAL:
    case VAR:
    case DEF:
    case TYPE:
    case ASSERT:
    case DATATYPE:
    case FORWARD:
    case NONE:
    case REQUIRE:
    case NEW:
    case ABSTRACT:
    case TAGGED:
    case MATCH:
    case RESOURCE:
    case INSTANTIATE:
    case EFFECT:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      exp = Script(imports, requires);
{if ("" != null) return exp;}
      break;
      }
    default:
      jj_la1[0] = jj_gen;
{if ("" != null) return build.unitValue(null);}
    }
    throw new Error("Missing return statement in function");
  }

/** Root production. */
  final public void ImportDecls(LinkedList<AST> decls) throws ParseException {AST exp1; AST exp2;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IMPORT:{
      exp1 = ImportDecl();
decls.addLast(exp1);
      ImportDecls(decls);
      break;
      }
    default:
      jj_la1[1] = jj_gen;

    }
  }

  final public AST ModuleDecl(LinkedList<AST> preImports) throws ParseException {LinkedList<AST> postImports= new LinkedList<AST>(); AST exp; Token id; Type type = null; List<GenericParameter> generics = null; List moduleArgs = new LinkedList(); boolean isResource = false; Token effects = null;
    if (jj_2_1(50)) {
      jj_consume_token(MODULE);
      jj_consume_token(DEF);
      id = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACK:{
        generics = GenericsDecl();
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        ;
      }
      moduleArgs = Formals();
      jj_consume_token(COLON);
      effects = jj_consume_token(DSL_LITERAL);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:
      case LPAREN:{
        type = Type();
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      jj_consume_token(NEWLINE);
      exp = ModuleBody(postImports);
if (effects == null) {
           {if ("" != null) return build.moduleDecl(id.image, preImports, generics, moduleArgs, postImports, exp, type, loc(id), true, true, null);}
        }
        {if ("" != null) return build.moduleDecl(id.image, preImports, generics, moduleArgs, postImports, exp, type, loc(id), true, true, effects.image);}
    } else if (jj_2_2(2)) {
      jj_consume_token(MODULE);
      jj_consume_token(DEF);
      id = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACK:{
        generics = GenericsDecl();
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      moduleArgs = Formals();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COLON:{
        jj_consume_token(COLON);
        type = Type();
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      jj_consume_token(NEWLINE);
      exp = ModuleBody(postImports);
{if ("" != null) return build.moduleDecl(id.image, preImports, generics, moduleArgs, postImports, exp, type, loc(id), true, false, null);}
    } else if (jj_2_3(5)) {
      jj_consume_token(MODULE);
      id = jj_consume_token(IDENTIFIER);
      jj_consume_token(COLON);
      effects = jj_consume_token(DSL_LITERAL);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:
      case LPAREN:{
        type = Type();
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      jj_consume_token(NEWLINE);
      exp = ModuleBody(postImports);
{if ("" != null) return build.moduleDecl(id.image, preImports, generics, moduleArgs, postImports, exp, type, loc(id), isResource, true, effects.image);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MODULE:{
        jj_consume_token(MODULE);
        id = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:{
          jj_consume_token(COLON);
          type = Type();
          break;
          }
        default:
          jj_la1[7] = jj_gen;
          ;
        }
        jj_consume_token(NEWLINE);
        exp = ModuleBody(postImports);
{if ("" != null) return build.moduleDecl(id.image, preImports, generics, moduleArgs, postImports, exp, type, loc(id), isResource, false, null);}
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public AST Script(LinkedList<AST> imports, LinkedList<AST> requires) throws ParseException {AST ast; AST decl;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VAL:
    case VAR:
    case DEF:
    case TYPE:
    case ASSERT:
    case DATATYPE:
    case FORWARD:
    case NONE:
    case NEW:
    case ABSTRACT:
    case TAGGED:
    case MATCH:
    case RESOURCE:
    case INSTANTIATE:
    case EFFECT:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      ast = DeclSequence(false);
{if ("" != null) return build.script(requires, imports, ast);}
      break;
      }
    case REQUIRE:{
      decl = RequireDecl();
requires.addLast(decl);
      ast = PostRequireScript(imports, requires);
{if ("" != null) return ast;}
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AST PostRequireScript(LinkedList<AST> imports, LinkedList<AST> requires) throws ParseException {AST ast; AST decl;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VAL:
    case VAR:
    case DEF:
    case TYPE:
    case ASSERT:
    case DATATYPE:
    case FORWARD:
    case NONE:
    case NEW:
    case ABSTRACT:
    case TAGGED:
    case MATCH:
    case IMPORT:
    case RESOURCE:
    case INSTANTIATE:
    case EFFECT:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      ImportDecls(imports);
      ast = DeclSequence(false);
{if ("" != null) return build.script(requires, imports, ast);}
      break;
      }
    case REQUIRE:{
      decl = RequireDecl();
requires.addLast(decl);
      ast = PostRequireScript(imports, requires);
{if ("" != null) return ast;}
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AST ModuleBody(LinkedList<AST> imports) throws ParseException {AST ast; AST decl;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VAL:
    case VAR:
    case DEF:
    case TYPE:
    case ASSERT:
    case DATATYPE:
    case FORWARD:
    case NONE:
    case NEW:
    case ABSTRACT:
    case TAGGED:
    case MATCH:
    case RESOURCE:
    case INSTANTIATE:
    case EFFECT:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      ast = DeclSequence(true);
{if ("" != null) return ast;}
      break;
      }
    case IMPORT:{
      decl = ImportDecl();
imports.addLast(decl);
      ast = ModuleBody(imports);
{if ("" != null) return build.sequence(decl,ast,true);}
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AST TopLevelCode() throws ParseException {AST ast; AST decl;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VAL:
    case VAR:
    case DEF:
    case TYPE:
    case ASSERT:
    case DATATYPE:
    case FORWARD:
    case NONE:
    case NEW:
    case ABSTRACT:
    case TAGGED:
    case MATCH:
    case RESOURCE:
    case INSTANTIATE:
    case EFFECT:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      ast = DeclSequence(false);
{if ("" != null) return ast;}
      break;
      }
    case REQUIRE:{
      decl = RequireDecl();
      ast = TopLevelCode();
{if ("" != null) return build.sequence(decl,ast,false);}
      break;
      }
    case IMPORT:{
      decl = ImportDecl();
      ast = TopLevelCode();
{if ("" != null) return build.sequence(decl,ast,false);}
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AST RequireDecl() throws ParseException {URI uri; Token t; Token name = null;
    t = jj_consume_token(REQUIRE);
    uri = Uri();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AS:{
      jj_consume_token(AS);
      name = jj_consume_token(IDENTIFIER);
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    jj_consume_token(NEWLINE);
{if ("" != null) return build.importDecl(uri, loc(t), name, true, false, false);}
    throw new Error("Missing return statement in function");
  }

  final public AST ImportDecl() throws ParseException {URI uri; Token t; Token name = null; Token meta = null;
    if (jj_2_4(2)) {
      t = jj_consume_token(IMPORT);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case METADATA:{
        meta = jj_consume_token(METADATA);
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      uri = Uri();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AS:{
        jj_consume_token(AS);
        name = jj_consume_token(IDENTIFIER);
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      jj_consume_token(NEWLINE);
{if ("" != null) return build.importDecl(uri, loc(t), name, false, meta != null, false);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IMPORT:{
        t = jj_consume_token(IMPORT);
        jj_consume_token(LIFTED);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case METADATA:{
          meta = jj_consume_token(METADATA);
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        uri = Uri();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case AS:{
          jj_consume_token(AS);
          name = jj_consume_token(IDENTIFIER);
          break;
          }
        default:
          jj_la1[17] = jj_gen;
          ;
        }
        jj_consume_token(NEWLINE);
{if ("" != null) return build.importDecl(uri, loc(t), name, false, meta != null, true);}
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public URI Uri() throws ParseException {Token t; String scheme = null; String s1; String s2; URI uri;
    if (jj_2_5(2)) {
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(COLON);
scheme = t.image;
    } else {
      ;
    }
    s1 = Segment();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DIVIDE:{
        ;
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        break label_1;
      }
      jj_consume_token(DIVIDE);
      s2 = Segment();
s1 = s1 + '/' + s2;
    }
if (scheme == null)
                        scheme = "wyv";
                try {
                        {if ("" != null) return new URI(scheme, s1, null);}
                } catch (Exception e) { {if (true) throw new RuntimeException(e);} }
    throw new Error("Missing return statement in function");
  }

  final public String Segment() throws ParseException {String s; Token t1;
    t1 = jj_consume_token(IDENTIFIER);
s = t1.image;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        ;
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        break label_2;
      }
      jj_consume_token(DOT);
      t1 = jj_consume_token(IDENTIFIER);
s = s + '.' + t1.image;
    }
{if ("" != null) return s;}
    throw new Error("Missing return statement in function");
  }

  final public AST DeclSequence(boolean inModule) throws ParseException {AST decl1; AST decl2;
    decl1 = Declaration(inModule);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VAL:
      case VAR:
      case DEF:
      case TYPE:
      case ASSERT:
      case DATATYPE:
      case FORWARD:
      case NONE:
      case NEW:
      case ABSTRACT:
      case TAGGED:
      case MATCH:
      case RESOURCE:
      case INSTANTIATE:
      case EFFECT:
      case RECUR:
      case IDENTIFIER:
      case LPAREN:
      case TILDE:
      case PLUS:
      case DASH:
      case BOOLEANNOT:
      case STRING_LITERAL:
      case CHARACTER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case DECIMAL_LITERAL:
      case BOOLEAN_LITERAL:
      case RATIONAL_LITERAL:
      case DSL_LITERAL:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_3;
      }
      decl2 = Declaration(inModule);
decl1 = build.sequence(decl1, decl2, inModule);
    }
{if ("" != null) return decl1;}
    throw new Error("Missing return statement in function");
  }

  final public String AbstractionDeclaration() throws ParseException {String abstractionLevel;
    jj_consume_token(ABSTRACT);
    jj_consume_token(LBRACK);
    abstractionLevel = Segment();
    jj_consume_token(RBRACK);
{if ("" != null) return abstractionLevel;}
    throw new Error("Missing return statement in function");
  }

  final public AST Declaration(boolean inModule) throws ParseException {String abstractionLevel=null; AST exp;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ABSTRACT:{
      abstractionLevel = AbstractionDeclaration();
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DEF:{
      exp = DefDeclaration();
{if ("" != null) return exp;}
      break;
      }
    case VAL:{
      exp = ValDeclaration();
{if ("" != null) return exp;}
      break;
      }
    case VAR:{
      exp = VarDeclaration();
{if ("" != null) return exp;}
      break;
      }
    case ASSERT:{
      exp = AssertDeclaration();
{if ("" != null) return exp;}
      break;
      }
    case EFFECT:{
      exp = EffectDeclaration();
{if ("" != null) return exp;}
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      if (jj_2_6(4)) {
        exp = TypeDeclaration();
{if ("" != null) return exp;}
      } else if (jj_2_7(4)) {
        exp = TaggedTypeDeclaration();
{if ("" != null) return exp;}
      } else if (jj_2_8(4)) {
        exp = DatatypeDeclaration(null);
{if ("" != null) return exp;}
      } else if (jj_2_9(4)) {
        exp = TypeAbbrevDeclaration();
{if ("" != null) return exp;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FORWARD:{
          exp = ForwardDeclaration();
{if ("" != null) return exp;}
          break;
          }
        case NONE:
        case NEW:
        case MATCH:
        case RECUR:
        case IDENTIFIER:
        case LPAREN:
        case TILDE:
        case PLUS:
        case DASH:
        case BOOLEANNOT:
        case STRING_LITERAL:
        case CHARACTER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DECIMAL_LITERAL:
        case BOOLEAN_LITERAL:
        case RATIONAL_LITERAL:
        case DSL_LITERAL:{
          exp = ExpressionLine(inModule);
{if ("" != null) return exp;}
          break;
          }
        case INSTANTIATE:{
          exp = Instantiation();
{if ("" != null) return exp;}
          break;
          }
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public AST DefDeclaration() throws ParseException {Type resultType; Token name; AST body; List args; List<GenericParameter> gentypes = null; Token effects = null;
    jj_consume_token(DEF);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      name = jj_consume_token(IDENTIFIER);
      break;
      }
    case PLUS:
    case DASH:
    case MULT:
    case DIVIDE:
    case MOD:{
      name = OverrideOperator();
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACK:{
      gentypes = GenericsDecl();
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    args = Formals();
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DSL_LITERAL:{
      effects = jj_consume_token(DSL_LITERAL);
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    resultType = Type();
    body = DefBody();
if (effects==null) {
        {if ("" != null) return build.defDecl(name.image, resultType, gentypes, args, body, false, loc(name), null);}
        }
        {if ("" != null) return build.defDecl(name.image, resultType, gentypes, args, body, false, loc(name), effects.image);}
    throw new Error("Missing return statement in function");
  }

  final public AST ValDeclaration() throws ParseException {Type type = null; Token name; AST body; List args;
    jj_consume_token(VAL);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      name = jj_consume_token(IDENTIFIER);
      break;
      }
    case STRING_LITERAL:{
      name = jj_consume_token(STRING_LITERAL);
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COLON:{
      jj_consume_token(COLON);
      type = Type();
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    jj_consume_token(EQUALS);
    body = ExpressionLine(false);
{if ("" != null) return build.valDecl(name.image, type, body, loc(name));}
    throw new Error("Missing return statement in function");
  }

  final public AST AssertDeclaration() throws ParseException {Token t; Token description = null; AST exp;
    t = jj_consume_token(ASSERT);
    if (jj_2_10(2)) {
      description = jj_consume_token(STRING_LITERAL);
      jj_consume_token(COLON);
    } else {
      ;
    }
    exp = ExpressionLine(false);
{if ("" != null) return build.assertion(description == null ? null : description.image, exp, loc(t));}
    throw new Error("Missing return statement in function");
  }

  final public AST TypeAbbrevDeclaration() throws ParseException {Token t = null; Type reference = null; Token alias = null; AST metadata = null;
    t = jj_consume_token(TYPE);
    alias = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALS:{
      jj_consume_token(EQUALS);
      reference = Type();
      break;
      }
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    jj_consume_token(NEWLINE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INDENT:{
      jj_consume_token(INDENT);
      jj_consume_token(METADATA);
      metadata = ExpressionLine(false);
      jj_consume_token(DEDENT);
      break;
      }
    default:
      jj_la1[31] = jj_gen;
      ;
    }
{if ("" != null) return build.typeAbbrevDecl(alias.image, reference, metadata, loc(t));}
    throw new Error("Missing return statement in function");
  }

  final public AST VarDeclaration() throws ParseException {Type type; Token name; AST body; List args;
    jj_consume_token(VAR);
    name = jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    type = Type();
    jj_consume_token(EQUALS);
    body = ExpressionLine(false);
{if ("" != null) return build.varDecl(name.image, type, body, loc(name));}
    throw new Error("Missing return statement in function");
  }

  final public AST EffectDeclaration() throws ParseException {Token name; Token effects;
    jj_consume_token(EFFECT);
    name = jj_consume_token(IDENTIFIER);
    jj_consume_token(EQUALS);
    effects = jj_consume_token(DSL_LITERAL);
    jj_consume_token(NEWLINE);
{if ("" != null) return build.effectDecl(name.image, effects.image, loc(name));}
    throw new Error("Missing return statement in function");
  }

  final public AST ForwardDeclaration() throws ParseException {Type type; Token t; AST exp;
    t = jj_consume_token(FORWARD);
    type = Type();
    jj_consume_token(TO);
    exp = ExpressionLine(false);
{if ("" != null) return build.forwardDecl(type, exp, loc(t));}
    throw new Error("Missing return statement in function");
  }

// while declaration
//AST WhileDeclaration() :
//{}
//{}
  final public 
AST TypeDeclaration() throws ParseException {Token name; AST body = null; AST metadata = null; Type extendedType=null; List<Type> comprisesList=null; boolean isTagged = false;
  Token selfName = null;
  Object tagInfo = null; boolean isResource = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RESOURCE:{
      jj_consume_token(RESOURCE);
isResource = true;
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    jj_consume_token(TYPE);
    name = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
      jj_consume_token(EXTENDS);
      extendedType = Type();
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMPRISES:{
      jj_consume_token(COMPRISES);
      comprisesList = TypeList();
      break;
      }
    default:
      jj_la1[34] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      selfName = jj_consume_token(IDENTIFIER);
      jj_consume_token(RPAREN);
      jj_consume_token(EQARROW);
      break;
      }
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    jj_consume_token(NEWLINE);
    jj_consume_token(INDENT);
    body = DeclTypes(selfName);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case METADATA:{
      jj_consume_token(METADATA);
      metadata = ExpressionLine(false);
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(DEDENT);
if (isTagged || (extendedType != null) || (comprisesList != null)) {
      tagInfo = build.tagInfo(extendedType, comprisesList);
    }
    String self = (selfName == null) ? null : selfName.image;
        {if ("" != null) return build.typeDecl(name.image, body, tagInfo, metadata, loc(name), isResource, self);}
    throw new Error("Missing return statement in function");
  }

  final public AST TaggedTypeDeclaration() throws ParseException {Token name; AST body = null; AST metadata = null; Type extendedType=null; List<Type> comprisesList=null; boolean isTagged = false;
  Token selfName = null;
  Object tagInfo = null; boolean isResource = false;
    jj_consume_token(TAGGED);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RESOURCE:{
      jj_consume_token(RESOURCE);
isResource = true;
      break;
      }
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    jj_consume_token(TYPE);
    name = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
      jj_consume_token(EXTENDS);
      extendedType = Type();
      break;
      }
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMPRISES:{
      jj_consume_token(COMPRISES);
      comprisesList = TypeList();
      break;
      }
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      selfName = jj_consume_token(IDENTIFIER);
      jj_consume_token(RPAREN);
      jj_consume_token(EQARROW);
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    jj_consume_token(NEWLINE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INDENT:{
      jj_consume_token(INDENT);
      body = DeclTypes(selfName);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case METADATA:{
        jj_consume_token(METADATA);
        metadata = ExpressionLine(false);
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      jj_consume_token(DEDENT);
      break;
      }
    default:
      jj_la1[42] = jj_gen;
      ;
    }
tagInfo = build.tagInfo(extendedType, comprisesList);
    String self = (selfName == null) ? null : selfName.image;
        {if ("" != null) return build.typeDecl(name.image, body, tagInfo, metadata, loc(name), isResource, self);}
    throw new Error("Missing return statement in function");
  }

  final public AST DatatypeDeclaration(String outerThisName) throws ParseException {Token name; AST body = null; AST metadata = null; Type extendedType=null; List<Type> comprisesList=null; boolean isTagged = false;
  List<GenericParameter> gentypes = null;
  Object tagInfo = null; boolean isResource = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RESOURCE:{
      jj_consume_token(RESOURCE);
isResource = true;
      break;
      }
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    jj_consume_token(DATATYPE);
    name = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACK:{
      gentypes = GenericsDecl();
      break;
      }
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      jj_consume_token(IDENTIFIER);
      jj_consume_token(RPAREN);
      jj_consume_token(ARROW);
      break;
      }
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    jj_consume_token(NEWLINE);
    jj_consume_token(INDENT);
    body = DeclTypes(null);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case METADATA:{
      jj_consume_token(METADATA);
      metadata = ExpressionLine(false);
      break;
      }
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    jj_consume_token(DEDENT);
if (isTagged || (extendedType != null) || (comprisesList != null)) {
      tagInfo = build.tagInfo(extendedType, comprisesList);
    }
        {if ("" != null) return build.datatypeDecl(name.image, gentypes, body, tagInfo, metadata, loc(name), isResource, outerThisName);}
    throw new Error("Missing return statement in function");
  }

  final public AST DeclTypes(Token thisToken) throws ParseException {AST decl1; AST decl2; AST body;
  String thisName = thisToken == null ? "this" : thisToken.image;
    decl1 = DeclType(thisName);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VAL:
      case VAR:
      case DEF:
      case TYPE:
      case DATATYPE:
      case TAGGED:
      case RESOURCE:
      case EFFECT:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        break label_4;
      }
      decl2 = DeclType(thisName);
decl1 = build.sequence(decl1, decl2, true);
    }
{if ("" != null) return decl1;}
    throw new Error("Missing return statement in function");
  }

  final public AST DeclType(String thisName) throws ParseException {AST exp;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DEF:{
      exp = DefDeclType();
{if ("" != null) return exp;}
      break;
      }
    case VAL:{
      exp = ValDeclType();
{if ("" != null) return exp;}
      break;
      }
    case VAR:{
      exp = VarDeclType();
{if ("" != null) return exp;}
      break;
      }
    case EFFECT:{
      exp = EffectDeclType();
{if ("" != null) return exp;}
      break;
      }
    case IDENTIFIER:{
      exp = ConstructDeclType();
{if ("" != null) return exp;}
      break;
      }
    default:
      jj_la1[48] = jj_gen;
      if (jj_2_11(4)) {
        exp = TypeDeclaration();
{if ("" != null) return exp;}
      } else if (jj_2_12(4)) {
        exp = TaggedTypeDeclaration();
{if ("" != null) return exp;}
      } else if (jj_2_13(4)) {
        exp = DatatypeDeclaration(thisName);
{if ("" != null) return exp;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case TYPE:{
          exp = TypeAbbrevDeclaration();
{if ("" != null) return exp;}
          break;
          }
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public AST DefDeclType() throws ParseException {Type resultType; Token name; List args; List<GenericParameter> gentypes=null; Token effects = null;
    jj_consume_token(DEF);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      name = jj_consume_token(IDENTIFIER);
      break;
      }
    case PLUS:
    case DASH:
    case MULT:
    case DIVIDE:
    case MOD:{
      name = OverrideOperator();
      break;
      }
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACK:{
      gentypes = GenericsDecl();
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    args = Formals();
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DSL_LITERAL:{
      effects = jj_consume_token(DSL_LITERAL);
      break;
      }
    default:
      jj_la1[52] = jj_gen;
      ;
    }
    resultType = Type();
    jj_consume_token(NEWLINE);
if (effects==null) {
        {if ("" != null) return build.defDeclType(name.image, resultType, gentypes, args, loc(name), null);}
        }
        {if ("" != null) return build.defDeclType(name.image, resultType, gentypes, args, loc(name), effects.image);}
    throw new Error("Missing return statement in function");
  }

  final public AST ValDeclType() throws ParseException {Type type; Token name; List args;
    jj_consume_token(VAL);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      name = jj_consume_token(IDENTIFIER);
      break;
      }
    case STRING_LITERAL:{
      name = jj_consume_token(STRING_LITERAL);
      break;
      }
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COLON);
    type = Type();
    jj_consume_token(NEWLINE);
{if ("" != null) return build.valDeclType(name.image, type, loc(name));}
    throw new Error("Missing return statement in function");
  }

  final public AST VarDeclType() throws ParseException {Type type; Token name; List args;
    jj_consume_token(VAR);
    name = jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    type = Type();
    jj_consume_token(NEWLINE);
{if ("" != null) return build.varDeclType(name.image, type, loc(name));}
    throw new Error("Missing return statement in function");
  }

  final public AST EffectDeclType() throws ParseException {Token name; Token effects = null;
    if (jj_2_14(10)) {
      jj_consume_token(EFFECT);
      name = jj_consume_token(IDENTIFIER);
      jj_consume_token(LE);
      effects = jj_consume_token(DSL_LITERAL);
      jj_consume_token(NEWLINE);
{if ("" != null) return build.effectDeclType(name.image, effects.image, true, loc(name));}
    } else if (jj_2_15(10)) {
      jj_consume_token(EFFECT);
      name = jj_consume_token(IDENTIFIER);
      jj_consume_token(GE);
      effects = jj_consume_token(DSL_LITERAL);
      jj_consume_token(NEWLINE);
{if ("" != null) return build.effectDeclType(name.image, effects.image, false, loc(name));}
    } else if (jj_2_16(4)) {
      jj_consume_token(EFFECT);
      name = jj_consume_token(IDENTIFIER);
      jj_consume_token(EQUALS);
      effects = jj_consume_token(DSL_LITERAL);
      jj_consume_token(NEWLINE);
if (effects==null) {
        {if ("" != null) return build.effectDeclType(name.image, null, loc(name));}
        }
        {if ("" != null) return build.effectDeclType(name.image, effects.image, loc(name));}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EFFECT:{
        jj_consume_token(EFFECT);
        name = jj_consume_token(IDENTIFIER);
        jj_consume_token(NEWLINE);
{if ("" != null) return build.effectDeclType(name.image, null, loc(name));}
        break;
        }
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public AST ConstructDeclType() throws ParseException {Type resultType; Token name; List args = null; List<GenericParameter> gentypes=null; Token effects = null;
    name = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACK:{
      gentypes = GenericsDecl();
      break;
      }
    default:
      jj_la1[55] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      args = Formals();
      break;
      }
    default:
      jj_la1[56] = jj_gen;
      ;
    }
    jj_consume_token(NEWLINE);
{if ("" != null) return build.constructDeclType(name.image, gentypes, args, loc(name));}
    throw new Error("Missing return statement in function");
  }

  final public List Formals_Lambda() throws ParseException {List args = new LinkedList(); Object singleParameter;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      singleParameter = Formal_Lambda_NoEqArrow();
args.add(singleParameter);
            {if ("" != null) return args;}
      break;
      }
    case LPAREN:{
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        FormalsList_Lambda(args);
        break;
        }
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
{if ("" != null) return args;}
      break;
      }
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void FormalsList_Lambda(List args) throws ParseException {Object formal;
    formal = Formal_Lambda();
args.add(formal);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[59] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      formal = Formal_Lambda();
args.add(formal);
    }
  }

  final public Object Formal_Lambda() throws ParseException {Token id; Type type = null;
    id = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COLON:{
      jj_consume_token(COLON);
      type = Type();
      break;
      }
    default:
      jj_la1[60] = jj_gen;
      ;
    }
{if ("" != null) return build.formalArg(id.image, type);}
    throw new Error("Missing return statement in function");
  }

  final public Object Formal_Lambda_NoEqArrow() throws ParseException {Token id; Type type = null;
    id = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COLON:{
      jj_consume_token(COLON);
      type = NonArrowType();
      break;
      }
    default:
      jj_la1[61] = jj_gen;
      ;
    }
{if ("" != null) return build.formalArg(id.image, type);}
    throw new Error("Missing return statement in function");
  }

  final public List Formals() throws ParseException {List args = new LinkedList();
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      FormalsList(args);
      break;
      }
    default:
      jj_la1[62] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
{if ("" != null) return args;}
    throw new Error("Missing return statement in function");
  }

  final public void FormalsList(List args) throws ParseException {Object formal;
    formal = Formal();
args.add(formal);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[63] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      formal = Formal();
args.add(formal);
    }
  }

  final public Object Formal() throws ParseException {Token id; Type type;
    id = jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    type = Type();
{if ("" != null) return build.formalArg(id.image, type);}
    throw new Error("Missing return statement in function");
  }

  final public AST DefBody() throws ParseException {AST exp;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEWLINE:{
      jj_consume_token(NEWLINE);
      jj_consume_token(INDENT);
      exp = DeclSequence(false);
      jj_consume_token(DEDENT);
{if ("" != null) return exp;}
      break;
      }
    case EQUALS:{
      jj_consume_token(EQUALS);
      exp = ExpressionLine(false);
{if ("" != null) return exp;}
      break;
      }
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Token DSLLines() throws ParseException {Token t, t2; int beginColumn; String content = "";
    t = jj_consume_token(DSLLINE);
content = t.specialToken.image + t.image;
      beginColumn = t.specialToken.beginColumn;
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DSLLINE:{
        ;
        break;
        }
      default:
        jj_la1[65] = jj_gen;
        break label_7;
      }
      t2 = jj_consume_token(DSLLINE);
content = content + t2.specialToken.image + t2.image;
    }
//if (content.trim().length() == 0) {
    if (LexerUtils.isCommentsAndWhitespace(content)) {
      // just comments and whitespace, return null; didn't really find a DSL
      {if ("" != null) return null;}
    }
    t.image = content;
    t.beginColumn = beginColumn-1; // this DSL line should start where the indent did
    {if ("" != null) return t;}
    throw new Error("Missing return statement in function");
  }

  final public AST ExpressionLine(boolean makeValDecl) throws ParseException {AST exp; AST decls = null; Token t; Token t2 = null; Object caseArm; List cases; ExpFlags flags = new ExpFlags();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NONE:
    case NEW:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      exp = Expression(flags);
      t = jj_consume_token(NEWLINE);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INDENT:
      case DSLLINE:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INDENT:{
          t2 = jj_consume_token(INDENT);
          decls = DeclSequence(true);
          jj_consume_token(DEDENT);
          break;
          }
        case DSLLINE:{
          t2 = DSLLines();
          break;
          }
        default:
          jj_la1[66] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[67] = jj_gen;
        ;
      }
if (!flags.isEmpty()) {
        if (flags.getExpKind() == IndentedExpKind.NEW_KIND) {
            build.setNewBody(flags.getExp(), decls);
        } else if (flags.getExpKind() == IndentedExpKind.INVOKE_KIND) {
            if (t2 != null) {
                AST dsl = build.dsl(loc(t2));
                build.setDSLBody(dsl, t2.image);
                            build.addArgument(flags.getExp(),dsl);
                }
        } else if (t2 == null) {
            ToolError.reportError(ErrorMessage.EXPECTED_DSL_BLOCK, (HasLocation)flags.getExp());
        } else {
            build.setDSLBody(flags.getExp(), t2.image);
        }
    } else if (t2 != null) {
        ToolError.reportError(ErrorMessage.ILLEGAL_INDENTED_BLOCK, loc(t2));
    }

    // create a decl if requested (e.g. we are within a module)
    if (!makeValDecl)
        {if ("" != null) return exp;}
        else
                {if ("" != null) return build.valDecl(freshName(), null, exp, loc(t));}
      break;
      }
    case MATCH:{
      t = jj_consume_token(MATCH);
      exp = Expression(flags);
      jj_consume_token(COLON);
      jj_consume_token(NEWLINE);
cases = new LinkedList();
      jj_consume_token(INDENT);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DEFLT:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[68] = jj_gen;
          break label_8;
        }
        caseArm = CaseArm();
cases.add(caseArm);
      }
      jj_consume_token(DEDENT);
{if ("" != null) return build.match(exp, cases, loc(t));}
      break;
      }
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Object CaseArm() throws ParseException {Token id; Token t; Token dslTok = null; AST exp = null; Type type=null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      id = jj_consume_token(IDENTIFIER);
      jj_consume_token(COLON);
      type = NonArrowType();
      break;
      }
    case DEFLT:{
      id = jj_consume_token(DEFLT);
      break;
      }
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(EQARROW);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NONE:
    case NEW:
    case MATCH:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      exp = ExpressionLine(false);
      break;
      }
    case NEWLINE:{
      jj_consume_token(NEWLINE);
      jj_consume_token(INDENT);
      exp = DeclSequence(false);
      jj_consume_token(DEDENT);
      break;
      }
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return build.caseArm(id.image,type,exp,loc(t));}
    throw new Error("Missing return statement in function");
  }

  final public AST Expression(ExpFlags flags) throws ParseException {AST exp; AST exp2 = null; Object formal; Token t = null;
    if (jj_2_17(4)) {
      exp = LambdaFn(flags);
{if ("" != null) return exp;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NONE:
      case NEW:
      case RECUR:
      case IDENTIFIER:
      case LPAREN:
      case TILDE:
      case PLUS:
      case DASH:
      case BOOLEANNOT:
      case STRING_LITERAL:
      case CHARACTER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case DECIMAL_LITERAL:
      case BOOLEAN_LITERAL:
      case RATIONAL_LITERAL:
      case DSL_LITERAL:{
        exp = AssignmentExpression(flags);
{if ("" != null) return exp;}
        break;
        }
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public AST AssignmentExpression(ExpFlags flags) throws ParseException {AST exp; AST exp2 = null; Object formal; Token t = null;
    exp = BooleanRelationalExpression(flags);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALS:{
      t = jj_consume_token(EQUALS);
      exp2 = Expression(flags);
      break;
      }
    default:
      jj_la1[73] = jj_gen;
      ;
    }
if (exp2 != null) {
        {if ("" != null) return build.assignment(exp, exp2, loc(t));}
    }
    {if ("" != null) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public AST LambdaFn(ExpFlags flags) throws ParseException {List formals; AST body; Token t;
    formals = Formals_Lambda();
    t = jj_consume_token(EQARROW);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NONE:
    case NEW:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      body = Expression(flags);
      break;
      }
    case INDENT:{
      jj_consume_token(INDENT);
      body = DeclSequence(false);
      jj_consume_token(DEDENT);
      break;
      }
    default:
      jj_la1[74] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return build.fn(formals, body, loc(t));}
    throw new Error("Missing return statement in function");
  }

  final public List<Type> TypeList() throws ParseException {List<Type> types = new LinkedList<Type>(); Type type;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:
    case LPAREN:{
      type = Type();
types.add(type);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[75] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMMA);
        type = Type();
types.add(type);
      }
{if ("" != null) return types;}
      break;
      }
    default:
      jj_la1[76] = jj_gen;
{if ("" != null) return types;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Type Type() throws ParseException {Type arrowResult = null; Token ar=null; Type t; Type t2; List<Type> tList=null; Token effects = null;
    t = NonArrowType();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:{
        ;
        break;
        }
      default:
        jj_la1[77] = jj_gen;
        break label_10;
      }
      jj_consume_token(MULT);
      t2 = NonArrowType();
if (tList == null) {
       tList = new LinkedList<Type>();
       tList.add(t);
   }
   tList.add(t2);
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQARROW:
    case TARROW:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TARROW:{
        ar = jj_consume_token(TARROW);
        break;
        }
      case EQARROW:{
        ar = jj_consume_token(EQARROW);
        break;
        }
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DSL_LITERAL:{
        effects = jj_consume_token(DSL_LITERAL);
        break;
        }
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      arrowResult = Type();
      break;
      }
    default:
      jj_la1[80] = jj_gen;
      ;
    }
if (arrowResult == null) {
        {if ("" != null) return t;}
    } else {
        if (tList == null) {
            tList = new LinkedList<Type>();
            tList.add(t);
        }
        boolean resourceArrow = (ar.kind == TARROW);
        {if ("" != null) return build.arrowType(tList, arrowResult, resourceArrow, effects == null ? null : effects.image, loc(ar));}
    }
    throw new Error("Missing return statement in function");
  }

  final public Type NonArrowType() throws ParseException {Type regularType; Type optionType;
    if (jj_2_18(50)) {
      optionType = OptionType();
{if ("" != null) return optionType;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:
      case LPAREN:{
        regularType = RegularType();
{if ("" != null) return regularType;}
        break;
        }
      default:
        jj_la1[81] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Type OptionType() throws ParseException {Token questionMark; AST exp; List<GenericArgument> generics; Type t; GenericArgument genArg = null;
    // syntactic sugar for option types
        // T? as sugar for option.Option[T] (T stands for a type)
        genArg = GenericArgumentRegularType();
    questionMark = jj_consume_token(QUESTION);
exp = build.var("option", loc(questionMark));
        t = build.qualifiedType(exp, "Option");

        // add the generic argument to the generics linked list
        generics = new LinkedList<GenericArgument>();
        generics.add(genArg);

        Object o = build.parameterizedType(t, generics, loc(questionMark));
        t = (Type) o;

        {if ("" != null) return t;}
    throw new Error("Missing return statement in function");
  }

  final public AST OptionNoneValue() throws ParseException {Token none; AST exp; AST lhs; List<AST> rhs; List<GenericArgument> generics; GenericArgument genArg = null; Type type;
    // built-in None value that works for all T. NONE = option.None[Dyn] <: option.None[T] for all T
        // NONE is equivalent to option.None[Dyn]
        none = jj_consume_token(NONE);
lhs = build.var("option", loc(none));
        exp = build.invocation(lhs, "None", null, loc(none));

        // generate generics
        generics = new LinkedList<GenericArgument>();
        type = build.nominalType("Dyn", loc(none)); // create Dynamic type
        genArg = new GenericArgument(GenericKind.TYPE, type);
        generics.add(genArg);

        // generate rhs (Arguments)
        rhs = new LinkedList<AST>(); // initialize empty AST list for rhs
        exp = build.application(exp, rhs, null, generics, /*recur*/false);

        {if ("" != null) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Type RegularType() throws ParseException {Token id = null; Token id2 = null; AST exp = null; List<GenericArgument> generics = null; Type t = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      t = Type();
      jj_consume_token(RPAREN);
{if ("" != null) return t;}
      break;
      }
    case IDENTIFIER:{
      id = jj_consume_token(IDENTIFIER);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DOT:{
          ;
          break;
          }
        default:
          jj_la1[82] = jj_gen;
          break label_11;
        }
        jj_consume_token(DOT);
        id2 = jj_consume_token(IDENTIFIER);
if (exp == null) {
        exp = build.var(id.image, loc(id));
    } else {
        exp = build.invocation(exp, id.image, null, loc(id));
    }
    id = id2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACK:{
        generics = Generics();
        break;
        }
      default:
        jj_la1[83] = jj_gen;
        ;
      }
if (exp == null) {
        t = build.nominalType(id.image, loc(id));
    } else {
        t = build.qualifiedType(exp, id2.image);
    }

    if (generics != null) {
        Object o = build.parameterizedType(t, generics, loc(id));
        t = (Type) o;
    }
    {if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AST BooleanRelationalExpression(ExpFlags flags) throws ParseException {AST exp; AST exp2 = null; Token t;
    exp = RelationalExpression(flags);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEANAND:
    case BOOLEANOR:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEANAND:{
        t = jj_consume_token(BOOLEANAND);
        break;
        }
      case BOOLEANOR:{
        t = jj_consume_token(BOOLEANOR);
        break;
        }
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      exp2 = BooleanRelationalExpression(flags);
exp = build.invocation(exp, t.image, exp2, loc(t));
      break;
      }
    default:
      jj_la1[86] = jj_gen;
      ;
    }
{if ("" != null) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public AST RelationalExpression(ExpFlags flags) throws ParseException {AST exp; AST exp2 = null; Token t;
    exp = AdditiveExpression(flags);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALSEQUALS:
    case GE:
    case LE:
    case NOTEQUALS:
    case GT:
    case LT:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case GT:{
        t = jj_consume_token(GT);
        break;
        }
      case LT:{
        t = jj_consume_token(LT);
        break;
        }
      case EQUALSEQUALS:{
        t = jj_consume_token(EQUALSEQUALS);
        break;
        }
      case LE:{
        t = jj_consume_token(LE);
        break;
        }
      case GE:{
        t = jj_consume_token(GE);
        break;
        }
      case NOTEQUALS:{
        t = jj_consume_token(NOTEQUALS);
        break;
        }
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      exp2 = AdditiveExpression(flags);
exp = build.invocation(exp, t.image, exp2, loc(t));
      break;
      }
    default:
      jj_la1[88] = jj_gen;
      ;
    }
{if ("" != null) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public AST AdditiveExpression(ExpFlags flags) throws ParseException {AST exp; AST exp2 = null; Token t;
    exp = MultiplicativeExpression(flags);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case DASH:{
        ;
        break;
        }
      default:
        jj_la1[89] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        t = jj_consume_token(PLUS);
        break;
        }
      case DASH:{
        t = jj_consume_token(DASH);
        break;
        }
      default:
        jj_la1[90] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      exp2 = MultiplicativeExpression(flags);
exp = build.invocation(exp, t.image, exp2, loc(t));
    }
{if ("" != null) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public AST MultiplicativeExpression(ExpFlags flags) throws ParseException {AST exp; AST exp2 = null; Token t;
    exp = UnaryExpression(flags);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:
      case DIVIDE:
      case MOD:{
        ;
        break;
        }
      default:
        jj_la1[91] = jj_gen;
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:{
        t = jj_consume_token(MULT);
        break;
        }
      case DIVIDE:{
        t = jj_consume_token(DIVIDE);
        break;
        }
      case MOD:{
        t = jj_consume_token(MOD);
        break;
        }
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      exp2 = UnaryExpression(flags);
exp = build.invocation(exp, t.image, exp2, loc(t));
    }
{if ("" != null) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public AST UnaryExpression(ExpFlags flags) throws ParseException {AST exp; Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PLUS:{
      jj_consume_token(PLUS);
      exp = UnaryExpression(flags);
{if ("" != null) return exp;}
      break;
      }
    case DASH:{
      t = jj_consume_token(DASH);
      exp = UnaryExpression(flags);
{if ("" != null) return build.invocation(exp, "negate", build.unitValue(loc(t)), loc(t));}
      break;
      }
    case BOOLEANNOT:{
      t = jj_consume_token(BOOLEANNOT);
      exp = UnaryExpression(flags);
{if ("" != null) return build.invocation(exp, "!", build.unitValue(loc(t)), loc(t));}
      break;
      }
    case NONE:
    case NEW:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      exp = PrimaryExpression(flags);
{if ("" != null) return exp;}
      break;
      }
    default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AST PrimaryExpression(ExpFlags flags) throws ParseException {AST exp; Token t; Token selfName = null;
  LinkedList<String> names = new LinkedList<String>();
  LinkedList<AST> args = new LinkedList<AST>();
  Token r = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RECUR:{
        r = jj_consume_token(RECUR);
        break;
        }
      default:
        jj_la1[94] = jj_gen;
        ;
      }
boolean recur = r != null;
      exp = PrimaryPrefix(flags);
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:
        case DOT:
        case LBRACK:{
          ;
          break;
          }
        default:
          jj_la1[95] = jj_gen;
          break label_14;
        }
        exp = PrimarySuffix(exp,flags, recur);
      }
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:
        case DSL_LITERAL:{
          ;
          break;
          }
        default:
          jj_la1[96] = jj_gen;
          break label_15;
        }
        Extension(names, args);
      }
if (names.size() + args.size() > 0) {
      exp = build.addArguments(exp,names,args);
    }
    flags.setExp(exp, IndentedExpKind.INVOKE_KIND);
    {if ("" != null) return exp;}
      break;
      }
    case NONE:{
      exp = OptionNoneValue();
{if ("" != null) return exp;}
      break;
      }
    case NEW:{
      t = jj_consume_token(NEW);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
        jj_consume_token(LPAREN);
        selfName = jj_consume_token(IDENTIFIER);
        jj_consume_token(RPAREN);
        jj_consume_token(EQARROW);
        break;
        }
      default:
        jj_la1[97] = jj_gen;
        ;
      }
String self = (selfName == null) ? null : selfName.image;
    exp = build.newObj(loc(t), self);

    // store a reference to the new expression so we can fill in the fields later!
    flags.setExp(exp, IndentedExpKind.NEW_KIND);
    {if ("" != null) return exp;}
      break;
      }
    default:
      jj_la1[98] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void Extension(LinkedList<String> names, LinkedList<AST> args) throws ParseException {AST exp; Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      t = jj_consume_token(IDENTIFIER);
names.addLast(t.image);
      break;
      }
    case DSL_LITERAL:{
      t = jj_consume_token(DSL_LITERAL);
if (!names.isEmpty())
        names.addLast("ARG"); // track parameters past the first keyword
    exp = build.dsl(loc(t));
    build.setDSLBody(exp, t.image);
    args.addLast(exp);
      break;
      }
    default:
      jj_la1[99] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public AST PrimaryPrefix(ExpFlags flags) throws ParseException {AST exp; Token t; Token t2 = null; boolean recur = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      exp = Literal();
{if ("" != null) return exp;}
      break;
      }
    case RECUR:
    case IDENTIFIER:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RECUR:{
        jj_consume_token(RECUR);
        break;
        }
      default:
        jj_la1[100] = jj_gen;
        ;
      }
recur = true;
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEANNOT:{
        t2 = jj_consume_token(BOOLEANNOT);
        break;
        }
      default:
        jj_la1[101] = jj_gen;
        ;
      }
{if ("" != null) return build.var(t.image, loc(t), t2 != null);}
      break;
      }
    case LPAREN:{
      jj_consume_token(LPAREN);
      exp = Expression(flags);
      jj_consume_token(RPAREN);
{if ("" != null) return exp;}
      break;
      }
    case TILDE:{
      t = jj_consume_token(TILDE);
exp = build.dsl(loc(t));
    flags.setExp(exp, IndentedExpKind.DSL_KIND);
    {if ("" != null) return exp;}
      break;
      }
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AST Literal() throws ParseException {AST exp; Token lit;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RATIONAL_LITERAL:{
      lit = jj_consume_token(RATIONAL_LITERAL);
{if ("" != null) return build.rationalLit(lit.image, loc(lit));}
      break;
      }
    case FLOATING_POINT_LITERAL:{
      lit = jj_consume_token(FLOATING_POINT_LITERAL);
{if ("" != null) return build.floatLit(Float.parseFloat(lit.image), loc(lit));}
      break;
      }
    case STRING_LITERAL:{
      lit = jj_consume_token(STRING_LITERAL);
{if ("" != null) return build.stringLit(lit.image, loc(lit));}
      break;
      }
    case CHARACTER_LITERAL:{
      lit = jj_consume_token(CHARACTER_LITERAL);
{if ("" != null) return build.characterLit(lit.image.charAt(0), loc(lit));}
      break;
      }
    case DECIMAL_LITERAL:{
      lit = jj_consume_token(DECIMAL_LITERAL);
{if ("" != null) return build.integerLit(new BigInteger(lit.image), loc(lit));}
      break;
      }
    case BOOLEAN_LITERAL:{
      lit = jj_consume_token(BOOLEAN_LITERAL);
{if ("" != null) return build.booleanLit(Boolean.parseBoolean(lit.image), loc(lit));}
      break;
      }
    case DSL_LITERAL:{
      lit = jj_consume_token(DSL_LITERAL);
exp = build.dsl(loc(lit));
    build.setDSLBody(exp, lit.image);
    {if ("" != null) return exp;}
      break;
      }
    default:
      jj_la1[103] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AST PrimarySuffix(AST lhs, ExpFlags flags, boolean recur) throws ParseException {List<AST> rhs; Token t; List<GenericArgument> generics = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DOT:{
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        t = jj_consume_token(IDENTIFIER);
        break;
        }
      case STRING_LITERAL:{
        t = jj_consume_token(STRING_LITERAL);
        break;
        }
      default:
        jj_la1[104] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return build.invocation(lhs, t.image, null, loc(t));}
      break;
      }
    case LPAREN:
    case LBRACK:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACK:{
        generics = Generics();
        break;
        }
      default:
        jj_la1[105] = jj_gen;
        ;
      }
      rhs = Arguments(flags);
{if ("" != null) return build.application(lhs, rhs, null, generics, recur);}
      break;
      }
    default:
      jj_la1[106] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public List<AST> Arguments(ExpFlags flags) throws ParseException {AST exp = null; List<AST> expList = null; Token t;
    t = jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NONE:
    case NEW:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      expList = ArgumentList(flags, loc(t));
      break;
      }
    default:
      jj_la1[107] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
{if ("" != null) return expList;}
    throw new Error("Missing return statement in function");
  }

  final public List<AST> ArgumentList(ExpFlags flags, FileLocation loc) throws ParseException {AST exp; AST exp2; LinkedList<AST> expList = new LinkedList<AST>(); Token t;
    exp = Expression(flags);
expList.add(exp);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[108] = jj_gen;
        break label_16;
      }
      t = jj_consume_token(COMMA);
      exp2 = Expression(flags);
expList.addLast(exp2);
    }
{if ("" != null) return expList;}
    throw new Error("Missing return statement in function");
  }

  final public List<AST> ExpressionList() throws ParseException {AST exp; LinkedList<AST> expList = new LinkedList<AST>(); ExpFlags flags = new ExpFlags(); Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NONE:
    case NEW:
    case RECUR:
    case IDENTIFIER:
    case LPAREN:
    case TILDE:
    case PLUS:
    case DASH:
    case BOOLEANNOT:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DECIMAL_LITERAL:
    case BOOLEAN_LITERAL:
    case RATIONAL_LITERAL:
    case DSL_LITERAL:{
      exp = Expression(flags);
expList.add(exp);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[109] = jj_gen;
          break label_17;
        }
        t = jj_consume_token(COMMA);
        exp = Expression(flags);
expList.add(exp);
      }
      break;
      }
    default:
      jj_la1[110] = jj_gen;
      ;
    }
{if ("" != null) return expList;}
    throw new Error("Missing return statement in function");
  }

  final public AST Instantiation() throws ParseException {URI uri; Token name; List<AST> args;
    jj_consume_token(INSTANTIATE);
    uri = Uri();
    args = Arguments(new ExpFlags());
    jj_consume_token(AS);
    name = jj_consume_token(IDENTIFIER);
    jj_consume_token(NEWLINE);
{if ("" != null) return build.instantiation(uri, args, name, loc(name));}
    throw new Error("Missing return statement in function");
  }

  final public Token OverrideOperator() throws ParseException {Token operator;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PLUS:{
      operator = jj_consume_token(PLUS);
{if ("" != null) return operator;}
      break;
      }
    case DASH:{
      operator = jj_consume_token(DASH);
{if ("" != null) return operator;}
      break;
      }
    case MULT:{
      operator = jj_consume_token(MULT);
{if ("" != null) return operator;}
      break;
      }
    case DIVIDE:{
      operator = jj_consume_token(DIVIDE);
{if ("" != null) return operator;}
      break;
      }
    case MOD:{
      operator = jj_consume_token(MOD);
{if ("" != null) return operator;}
      break;
      }
    default:
      jj_la1[111] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public List Generics() throws ParseException {List gens = null;
    jj_consume_token(LBRACK);
    gens = GenericList();
    jj_consume_token(RBRACK);
{if ("" != null) return gens;}
    throw new Error("Missing return statement in function");
  }

  final public List GenericList() throws ParseException {LinkedList<GenericArgument> genList = new LinkedList<GenericArgument>(); GenericArgument t1, t2;
    t1 = GenericArgument();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[112] = jj_gen;
        break label_18;
      }
      jj_consume_token(COMMA);
      t2 = GenericArgument();
genList.addLast(t2);
    }
genList.addFirst(t1);
    {if ("" != null) return genList;}
    throw new Error("Missing return statement in function");
  }

  final public GenericArgument GenericArgument() throws ParseException {Type type; Token effect;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:
    case LPAREN:{
      type = Type();
{if ("" != null) return new GenericArgument(GenericKind.TYPE, type);}
      break;
      }
    case DSL_LITERAL:{
      effect = jj_consume_token(DSL_LITERAL);
{if ("" != null) return new GenericArgument(effect.image);}
      break;
      }
    default:
      jj_la1[113] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public GenericArgument GenericArgumentRegularType() throws ParseException {Type type; Token effect;
    type = RegularType();
{if ("" != null) return new GenericArgument(GenericKind.TYPE, type);}
    throw new Error("Missing return statement in function");
  }

  final public List GenericsDecl() throws ParseException {List gens = null;
    jj_consume_token(LBRACK);
    gens = GenericListDecl();
    jj_consume_token(RBRACK);
{if ("" != null) return gens;}
    throw new Error("Missing return statement in function");
  }

  final public List GenericListDecl() throws ParseException {LinkedList<GenericParameter> genList = new LinkedList<GenericParameter>(); GenericParameter t1, t2;
    t1 = GenericParameter();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[114] = jj_gen;
        break label_19;
      }
      jj_consume_token(COMMA);
      t2 = GenericParameter();
genList.addLast(t2);
    }
genList.addFirst(t1);
    {if ("" != null) return genList;}
    throw new Error("Missing return statement in function");
  }

  final public GenericParameter GenericParameter() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EFFECT:{
      jj_consume_token(EFFECT);
      t = jj_consume_token(IDENTIFIER);
{if ("" != null) return new GenericParameter(GenericKind.EFFECT, t.image);}
      break;
      }
    case IDENTIFIER:{
      t = jj_consume_token(IDENTIFIER);
{if ("" != null) return new GenericParameter(GenericKind.TYPE, t.image);}
      break;
      }
    default:
      jj_la1[115] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_3R_97()
 {
    if (jj_3R_112()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_113()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_32()
 {
    if (jj_scan_token(LBRACK)) return true;
    if (jj_3R_55()) return true;
    if (jj_scan_token(RBRACK)) return true;
    return false;
  }

  private boolean jj_3R_101()
 {
    if (jj_scan_token(DEF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_3R_115()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_116()) jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    if (jj_scan_token(COLON)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(73)) jj_scanpos = xsp;
    if (jj_3R_34()) return true;
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_79()
 {
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_54()
 {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_65()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) return true;
    }
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_92()
 {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_162()
 {
    if (jj_scan_token(DSL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_161()
 {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_142()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) return true;
    }
    return false;
  }

  private boolean jj_3R_91()
 {
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_172()
 {
    if (jj_scan_token(NEWLINE)) return true;
    if (jj_scan_token(INDENT)) return true;
    if (jj_3R_60()) return true;
    if (jj_scan_token(DEDENT)) return true;
    return false;
  }

  private boolean jj_3R_90()
 {
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_171()
 {
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_170()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_57()) return true;
    return false;
  }

  private boolean jj_3R_157()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) return true;
    }
    if (jj_scan_token(EQARROW)) return true;
    xsp = jj_scanpos;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) return true;
    }
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_143()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_89()
 {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_94()
 {
    if (jj_scan_token(AS)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_130()
 {
    if (jj_3R_142()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_143()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_88()
 {
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_138()
 {
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3R_87()
 {
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_86()
 {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3R_124()
 {
    if (jj_scan_token(MATCH)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_scan_token(NEWLINE)) return true;
    if (jj_scan_token(INDENT)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_138()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(DEDENT)) return true;
    return false;
  }

  private boolean jj_3R_85()
 {
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3R_84()
 {
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3R_114()
 {
    if (jj_scan_token(LBRACK)) return true;
    if (jj_3R_130()) return true;
    if (jj_scan_token(RBRACK)) return true;
    return false;
  }

  private boolean jj_3R_146()
 {
    if (jj_scan_token(MULT)) return true;
    return false;
  }

  private boolean jj_3R_72()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_84()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_145()
 {
    if (jj_scan_token(DASH)) return true;
    return false;
  }

  private boolean jj_3R_22()
 {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_148()
 {
    if (jj_scan_token(MOD)) return true;
    return false;
  }

  private boolean jj_3R_93()
 {
    if (jj_scan_token(AS)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_147()
 {
    if (jj_scan_token(DIVIDE)) return true;
    return false;
  }

  private boolean jj_3R_144()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_100()
 {
    if (jj_scan_token(ABSTRACT)) return true;
    if (jj_scan_token(LBRACK)) return true;
    if (jj_3R_37()) return true;
    if (jj_scan_token(RBRACK)) return true;
    return false;
  }

  private boolean jj_3R_131()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_109()
 {
    if (jj_scan_token(DIVIDE)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_73()
 {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3R_126()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_60()
 {
    if (jj_3R_72()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_73()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_37()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_126()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_108()
 {
    if (jj_scan_token(INSTANTIATE)) return true;
    if (jj_3R_25()) return true;
    if (jj_3R_125()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_192()
 {
    if (jj_3R_200()) return true;
    return false;
  }

  private boolean jj_3R_156()
 {
    if (jj_3R_169()) return true;
    return false;
  }

  private boolean jj_3R_155()
 {
    if (jj_scan_token(INDENT)) return true;
    if (jj_3R_60()) return true;
    if (jj_scan_token(DEDENT)) return true;
    return false;
  }

  private boolean jj_3R_137()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    }
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_25()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_109()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_107()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) return true;
    }
    return false;
  }

  private boolean jj_3R_123()
 {
    if (jj_3R_65()) return true;
    if (jj_scan_token(NEWLINE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_137()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_139()
 {
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3R_173()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_74()
 {
    if (jj_scan_token(IMPORT)) return true;
    if (jj_scan_token(LIFTED)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(12)) jj_scanpos = xsp;
    if (jj_3R_25()) return true;
    xsp = jj_scanpos;
    if (jj_3R_94()) jj_scanpos = xsp;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_181()
 {
    if (jj_scan_token(DSLLINE)) return true;
    return false;
  }

  private boolean jj_3R_158()
 {
    if (jj_3R_65()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_173()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_61()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_scan_token(IMPORT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(12)) jj_scanpos = xsp;
    if (jj_3R_25()) return true;
    xsp = jj_scanpos;
    if (jj_3R_93()) jj_scanpos = xsp;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_24()
 {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_169()
 {
    if (jj_scan_token(DSLLINE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_181()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_125()
 {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_139()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_133()
 {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_117()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) return true;
    }
    return false;
  }

  private boolean jj_3R_132()
 {
    if (jj_scan_token(NEWLINE)) return true;
    if (jj_scan_token(INDENT)) return true;
    if (jj_3R_60()) return true;
    if (jj_scan_token(DEDENT)) return true;
    return false;
  }

  private boolean jj_3R_213()
 {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_203()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_213()) jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    return false;
  }

  private boolean jj_3R_202()
 {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) return true;
    }
    return false;
  }

  private boolean jj_3R_199()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    if (jj_3R_203()) return true;
    }
    return false;
  }

  private boolean jj_3R_191()
 {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_69()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_36()
 {
    if (jj_3R_61()) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_212()
 {
    if (jj_scan_token(DSL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_23()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    }
    return false;
  }

  private boolean jj_3R_35()
 {
    if (jj_3R_60()) return true;
    return false;
  }

  private boolean jj_3R_70()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_211()
 {
    if (jj_scan_token(BOOLEAN_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_33()
 {
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_95()
 {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_57()) return true;
    return false;
  }

  private boolean jj_3R_210()
 {
    if (jj_scan_token(DECIMAL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_56()
 {
    if (jj_3R_69()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_70()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_209()
 {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_208()
 {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_180()
 {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_207()
 {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_127()
 {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_20()
 {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_206()
 {
    if (jj_scan_token(RATIONAL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_201()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_21()
 {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_77()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_198()
 {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_197()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_196()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(27)) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(66)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_195()
 {
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_190()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_110()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_scan_token(MODULE)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_scan_token(DSL_LITERAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_24()) jj_scanpos = xsp;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_78()
 {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_111()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_179()
 {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_205()
 {
    if (jj_scan_token(DSL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_scan_token(MODULE)) return true;
    if (jj_scan_token(DEF)) return true;
    return false;
  }

  private boolean jj_3R_96()
 {
    if (jj_3R_110()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_111()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_204()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_200()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) return true;
    }
    return false;
  }

  private boolean jj_3R_194()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(EQARROW)) return true;
    return false;
  }

  private boolean jj_3R_64()
 {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_78()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_scan_token(MODULE)) return true;
    if (jj_scan_token(DEF)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_scan_token(DSL_LITERAL)) return true;
    xsp = jj_scanpos;
    if (jj_3R_22()) jj_scanpos = xsp;
    if (jj_scan_token(NEWLINE)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_63()
 {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_51()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    }
    return false;
  }

  private boolean jj_3R_189()
 {
    if (jj_scan_token(NEW)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_194()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_177()
 {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_188()
 {
    if (jj_3R_193()) return true;
    return false;
  }

  private boolean jj_3R_168()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_179()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_187()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(27)) jj_scanpos = xsp;
    if (jj_3R_190()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_191()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_192()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_186()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_178()
 {
    if (jj_scan_token(EFFECT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_185()
 {
    if (jj_3R_186()) return true;
    return false;
  }

  private boolean jj_3_16()
 {
    if (jj_scan_token(EFFECT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(EQUALS)) return true;
    if (jj_scan_token(DSL_LITERAL)) return true;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_184()
 {
    if (jj_scan_token(BOOLEANNOT)) return true;
    if (jj_3R_174()) return true;
    return false;
  }

  private boolean jj_3_15()
 {
    if (jj_scan_token(EFFECT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(GE)) return true;
    if (jj_scan_token(DSL_LITERAL)) return true;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_183()
 {
    if (jj_scan_token(DASH)) return true;
    if (jj_3R_174()) return true;
    return false;
  }

  private boolean jj_3R_176()
 {
    if (jj_3R_131()) return true;
    return false;
  }

  private boolean jj_3R_182()
 {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_174()) return true;
    return false;
  }

  private boolean jj_3R_174()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_167()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_14()
 {
    if (jj_scan_token(EFFECT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LE)) return true;
    if (jj_scan_token(DSL_LITERAL)) return true;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_175()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) return true;
    }
    }
    if (jj_3R_174()) return true;
    return false;
  }

  private boolean jj_3R_166()
 {
    if (jj_scan_token(VAR)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_34()) return true;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_159()
 {
    if (jj_3R_174()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_175()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_165()
 {
    if (jj_scan_token(VAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) return true;
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_34()) return true;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_160()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) return true;
    }
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_140()
 {
    if (jj_3R_159()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_160()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_164()
 {
    if (jj_scan_token(DEF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_3R_176()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_177()) jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    if (jj_scan_token(COLON)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(73)) jj_scanpos = xsp;
    if (jj_3R_34()) return true;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_141()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) return true;
    }
    }
    }
    }
    }
    if (jj_3R_140()) return true;
    return false;
  }

  private boolean jj_3R_128()
 {
    if (jj_3R_140()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_141()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_154()
 {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3_13()
 {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_129()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) return true;
    }
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3_12()
 {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_112()
 {
    if (jj_3R_128()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_129()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_11()
 {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_153()
 {
    if (jj_3R_168()) return true;
    return false;
  }

  private boolean jj_3R_152()
 {
    if (jj_3R_167()) return true;
    return false;
  }

  private boolean jj_3R_47()
 {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_151()
 {
    if (jj_3R_166()) return true;
    return false;
  }

  private boolean jj_3R_150()
 {
    if (jj_3R_165()) return true;
    return false;
  }

  private boolean jj_3R_98()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_149()
 {
    if (jj_3R_164()) return true;
    return false;
  }

  private boolean jj_3R_134()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_122()
 {
    if (jj_scan_token(METADATA)) return true;
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_135()
 {
    if (jj_3R_134()) return true;
    return false;
  }

  private boolean jj_3R_119()
 {
    if (jj_3R_134()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_135()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_99()
 {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_81()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_98()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_99()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_136()
 {
    if (jj_scan_token(METADATA)) return true;
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_48()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(ARROW)) return true;
    return false;
  }

  private boolean jj_3R_66()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    }
    return false;
  }

  private boolean jj_3R_80()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_34()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_46()
 {
    if (jj_scan_token(RESOURCE)) return true;
    return false;
  }

  private boolean jj_3R_28()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) jj_scanpos = xsp;
    if (jj_scan_token(DATATYPE)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_47()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) jj_scanpos = xsp;
    if (jj_scan_token(NEWLINE)) return true;
    if (jj_scan_token(INDENT)) return true;
    if (jj_3R_119()) return true;
    xsp = jj_scanpos;
    if (jj_3R_122()) jj_scanpos = xsp;
    if (jj_scan_token(DEDENT)) return true;
    return false;
  }

  private boolean jj_3R_121()
 {
    if (jj_scan_token(INDENT)) return true;
    if (jj_3R_119()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_136()) jj_scanpos = xsp;
    if (jj_scan_token(DEDENT)) return true;
    return false;
  }

  private boolean jj_3R_193()
 {
    if (jj_scan_token(NONE)) return true;
    return false;
  }

  private boolean jj_3R_45()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(EQARROW)) return true;
    return false;
  }

  private boolean jj_3R_44()
 {
    if (jj_scan_token(COMPRISES)) return true;
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_43()
 {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_120()
 {
    if (jj_scan_token(METADATA)) return true;
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_42()
 {
    if (jj_scan_token(RESOURCE)) return true;
    return false;
  }

  private boolean jj_3R_27()
 {
    if (jj_scan_token(TAGGED)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) jj_scanpos = xsp;
    if (jj_scan_token(TYPE)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_43()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) jj_scanpos = xsp;
    if (jj_scan_token(NEWLINE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_121()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_31()
 {
    if (jj_3R_54()) return true;
    if (jj_scan_token(QUESTION)) return true;
    return false;
  }

  private boolean jj_3R_41()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(EQARROW)) return true;
    return false;
  }

  private boolean jj_3R_40()
 {
    if (jj_scan_token(COMPRISES)) return true;
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_39()
 {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_38()
 {
    if (jj_scan_token(RESOURCE)) return true;
    return false;
  }

  private boolean jj_3R_26()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_38()) jj_scanpos = xsp;
    if (jj_scan_token(TYPE)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_39()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_40()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) jj_scanpos = xsp;
    if (jj_scan_token(NEWLINE)) return true;
    if (jj_scan_token(INDENT)) return true;
    if (jj_3R_119()) return true;
    xsp = jj_scanpos;
    if (jj_3R_120()) jj_scanpos = xsp;
    if (jj_scan_token(DEDENT)) return true;
    return false;
  }

  private boolean jj_3R_71()
 {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_57()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_118()
 {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_106()
 {
    if (jj_scan_token(FORWARD)) return true;
    if (jj_3R_34()) return true;
    if (jj_scan_token(TO)) return true;
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_116()
 {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_105()
 {
    if (jj_scan_token(EFFECT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(EQUALS)) return true;
    if (jj_scan_token(DSL_LITERAL)) return true;
    if (jj_scan_token(NEWLINE)) return true;
    return false;
  }

  private boolean jj_3R_113()
 {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_59()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(73)) jj_scanpos = xsp;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_103()
 {
    if (jj_scan_token(VAR)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_34()) return true;
    if (jj_scan_token(EQUALS)) return true;
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_58()
 {
    if (jj_scan_token(MULT)) return true;
    if (jj_3R_57()) return true;
    return false;
  }

  private boolean jj_3R_34()
 {
    if (jj_3R_57()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_58()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_59()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_50()
 {
    if (jj_scan_token(INDENT)) return true;
    if (jj_scan_token(METADATA)) return true;
    if (jj_3R_107()) return true;
    if (jj_scan_token(DEDENT)) return true;
    return false;
  }

  private boolean jj_3R_49()
 {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_76()
 {
    return false;
  }

  private boolean jj_3R_163()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_29()
 {
    if (jj_scan_token(TYPE)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) jj_scanpos = xsp;
    if (jj_scan_token(NEWLINE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_50()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_115()
 {
    if (jj_3R_131()) return true;
    return false;
  }

  private boolean jj_3R_62()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    }
    return false;
  }

  private boolean jj_3R_75()
 {
    if (jj_3R_34()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_163()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_83()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_67()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) return true;
    }
    return false;
  }

  private boolean jj_3R_82()
 {
    if (jj_scan_token(EFFECT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_53()
 {
    if (jj_scan_token(INDENT)) return true;
    if (jj_3R_60()) return true;
    if (jj_scan_token(DEDENT)) return true;
    return false;
  }

  private boolean jj_3R_104()
 {
    if (jj_scan_token(ASSERT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) jj_scanpos = xsp;
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_52()
 {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_30()
 {
    if (jj_3R_51()) return true;
    if (jj_scan_token(EQARROW)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    }
    return false;
  }

  private boolean jj_3R_68()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_102()
 {
    if (jj_scan_token(VAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_118()) jj_scanpos = xsp;
    if (jj_scan_token(EQUALS)) return true;
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_55()
 {
    if (jj_3R_67()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_68()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  /** User defined Token Manager. */
  public TokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[116];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xd8ceb7e,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0xd8cab7e,0xd9cab7e,0xd9ca37e,0xd9cab7e,0x2000000,0x1000,0x2000000,0x1000,0x2000000,0x100000,0x0,0x0,0xd8ca37e,0x8000,0x400002e,0x9082300,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x20000,0x10000,0x0,0x1000,0x800000,0x20000,0x10000,0x0,0x1000,0x0,0x800000,0x0,0x0,0x1000,0x484005e,0x400000e,0x10,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x400000,0x8082200,0x400000,0x88082200,0x8002200,0x0,0x8002200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8002200,0x8000000,0x0,0x0,0x0,0x8002200,0x0,0x8000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x8002200,0x0,0x0,0x8002200,0x0,0x0,0x0,0x0,0x4000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1d8,0x0,0x10000000,0x18,0x10000000,0x200000,0x18,0x200000,0x0,0x1d8,0x1d8,0x1d8,0x1d8,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x100000,0x1d8,0x0,0x0,0x1d8,0xf88,0x10000000,0x0,0x8,0x200000,0x1000,0x1,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x10,0x0,0x1,0x0,0x10000000,0x10,0x0,0x8,0x8,0x0,0xf88,0x10000000,0x0,0x8,0x0,0x10000000,0x10,0x8,0x18,0x20000,0x200000,0x200000,0x8,0x20000,0x1000,0x4,0x5,0x5,0x8,0x1d8,0x8,0x1d8,0x1d8,0x1000,0x1d9,0x20000,0x18,0x200,0xc0000,0x0,0xc0000,0x18,0x100000,0x10000000,0x18,0x0,0x0,0xc01e000,0xc01e000,0x180,0x180,0xe00,0xe00,0x1d8,0x0,0x10100010,0x8,0x10,0x58,0x8,0x0,0x0,0x58,0x0,0x8,0x10000000,0x10100010,0x1d8,0x20000,0x20000,0x1d8,0xf80,0x20000,0x18,0x20000,0x8,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x3fc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc,0x3fc,0x3fc,0x3fc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc,0x0,0x0,0x3fc,0x0,0x0,0x200,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc,0x0,0x3fc,0x3fc,0x0,0x3fc,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc,0x0,0x0,0x200,0x0,0x3f8,0x200,0x0,0x4,0x3f8,0x3f8,0x8,0x0,0x0,0x3fc,0x0,0x0,0x3fc,0x0,0x0,0x200,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[18];
  private boolean jj_rescan = false;
  private int jj_gc = 0;


  /** Constructor with user supplied Token Manager. */
  public WyvernParser(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 116; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 116; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[75];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 116; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 75; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 18; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
