/* Generated By:JJTree: Do not edit this line. ASTComponentTypeDecl.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,
NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package wyvern.tools.parsing.coreparser.arch;

import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

import wyvern.target.corewyvernIL.FormalArg;
import wyvern.target.corewyvernIL.decl.Declaration;
import wyvern.target.corewyvernIL.decl.DefDeclaration;
import wyvern.target.corewyvernIL.decltype.DeclType;
import wyvern.target.corewyvernIL.decltype.ValDeclType;
import wyvern.target.corewyvernIL.expression.Expression;
import wyvern.target.corewyvernIL.expression.New;
import wyvern.target.corewyvernIL.modules.Module;
import wyvern.target.corewyvernIL.support.InterpreterState;
import wyvern.target.corewyvernIL.type.NominalType;
import wyvern.target.corewyvernIL.type.StructuralType;
import wyvern.tools.errors.ErrorMessage;
import wyvern.tools.errors.ToolError;

public class ASTComponentTypeDecl extends SimpleNode {
    private boolean isExternal = false;
    private String typeName;
    // "reqs" maps port names to the interfaces they require
    private HashMap<String, String> reqs = new HashMap<>();
    // "provs" maps port names to the interfaces they provide
    private HashMap<String, String> provs = new HashMap<>();

    public ASTComponentTypeDecl(int id) {
        super(id);
    }

    public ASTComponentTypeDecl(ArchParser p, int id) {
        super(p, id);
    }

    public HashMap<String, String> getReqs() {
        return reqs;
    }

    public HashMap<String, String> getProvs() {
        return provs;
    }

    public boolean isExternal() {
        return isExternal;
    }

    public void setExternal(boolean isExternal) {
        this.isExternal = isExternal;
    }

    public String getTypeName() {
        return typeName;
    }

    public void setTypeName(String t) {
        typeName = t;
    }

    public String toString() {
        return super.toString() + " " + typeName + " : " + isExternal;
    }

    public void collectPorts() {
        for (Node child : this.getChildren()) {
            if (child instanceof ASTPortDecl) {
                String req = ((ASTPortDecl) child).getRequires();
                String prov = ((ASTPortDecl) child).getProvides();
                String name = ((ASTPortDecl) child).getPort();
                if (req != "") {
                    reqs.put(name, req);
                } else if (prov != "") {
                    provs.put(name, prov);
                }
            }
        }
    }

    public boolean checkModule(InterpreterState state) {
        if (isExternal) {
            return true;
        }
        Module mod = null;
        int checkCount = 0;
        try {
            mod = state.getResolver().resolveModule(typeName);

            /* Check that it's a module def */
            Expression expr = mod.getExpression();
            if (!expr.getType().toString().contains("apply(")) {
                System.out.println(expr.getType().toString());
                // throw error saying it's not a module def
                ToolError.reportError(ErrorMessage.MODULE_DEF_NOT_FOUND, this.getLocation(),
                        typeName);
            }

            List<Declaration> decls = ((New) expr).getDecls().stream()
                    .filter(p -> p instanceof DefDeclaration)
                    .collect(Collectors.toList());
            if (decls.size() == 1 && decls.get(0) instanceof DefDeclaration) {
                DefDeclaration d = (DefDeclaration) decls.get(0);
                /* Check for dependencies passed as args to module def */
                List<FormalArg> args = ((DefDeclaration) d).getFormalArgs();
                if (args.size() != reqs.size()) {
                    // inconsistent dependency errors
                    ToolError.reportError(
                            ErrorMessage.COMPONENT_DEPENDENCY_INCONSISTENCY, this.getLocation(),
                            typeName);
                }
                for (FormalArg f : args) {
                    String name = f.getName();
                    String type = ((NominalType) f.getType()).getTypeMember();
                    if (reqs.get(name) == null || !reqs.get(name).equals(type)) {
                        // inconsistent dependency error
                        ToolError.reportError(
                                ErrorMessage.COMPONENT_DEPENDENCY_INCONSISTENCY, this.getLocation(),
                                typeName);
                    }
                }

                /* Check that it exposes the correct fields */
                if (d.getType() instanceof StructuralType) {
                    List<DeclType> valdecltypes = ((StructuralType) (d.getType()))
                            .getDeclTypes().stream().filter(p -> p instanceof ValDeclType)
                            .collect(Collectors.toList());
                    for (DeclType dt : valdecltypes) {
                        ValDeclType vdtype = (ValDeclType) dt;
                        String name = vdtype.getName();
                        String t = ((NominalType) vdtype.getSourceType().getValueType())
                                .getTypeMember();
                        if (provs.get(name) == null || !provs.get(name).equals(t)) {
                            // inconsistent fields
                            ToolError.reportError(
                                    ErrorMessage.COMPONENT_DEPENDENCY_INCONSISTENCY, this.getLocation(),
                                    typeName);
                        } else {
                            checkCount++;
                        }
                    }
                    if (checkCount != valdecltypes.size()) {
                        // inconsistent fields
                        ToolError.reportError(
                                ErrorMessage.COMPONENT_DEPENDENCY_INCONSISTENCY, this.getLocation(),
                                typeName);
                    }
                }
            } else {
                ToolError.reportError(
                        ErrorMessage.COMPONENT_DEPENDENCY_INCONSISTENCY, this.getLocation(),
                        typeName);
            }

        } catch (ToolError e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Accept the visitor.
     **/
    public Object jjtAccept(ArchParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }
}
/*
 * JavaCC - OriginalChecksum=f5aec0da9432112df1e15710b91b7b28 (do not edit this
 * line)
 */
